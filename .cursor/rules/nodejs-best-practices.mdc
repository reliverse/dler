---
description: Node.js CLI development best practices
alwaysApply: false
---
This document provides guidelines for building Node.js command-line applications. Follow these rules strictly when developing CLI tools.

## 1. Command Line Experience

### 1.1 Respect POSIX Arguments

**RULE**: Always use POSIX-compliant command line argument syntax.

**DO**:

- Use `--long-option` for long options
- Use `-s` for short options (single letter)
- Allow grouped short options: `-abc` equivalent to `-a -b -c`
- Use `[]` for optional arguments, `<>` for required arguments
- Follow standard help text format

**DON'T**:

- Create non-standard argument syntax
- Use single dash for multi-character options
- Deviate from Unix command conventions

**Example**:

```typescript
// ✅ Correct: POSIX-compliant
program
  .option('-f, --file <path>', 'input file path')
  .option('-v, --verbose', 'enable verbose output')
  .option('-c, --config [path]', 'config file (optional)');

// ❌ Wrong: Non-standard syntax
program
  .option('-file <path>', 'input file path')  // Missing double dash
  .option('--v', 'enable verbose output');    // Single dash for long option
```

**Required packages**: Use `commander` or `yargs` for argument parsing.

### 1.2 Build Empathic CLIs

**RULE**: Provide interactive assistance when users make mistakes.

**DO**:

- Detect missing required arguments
- Offer interactive prompts for missing data
- Provide helpful error messages with solutions
- Suggest correct usage patterns

**Example**:

```typescript
// ✅ Good: Interactive assistance
if (!options.file) {
  const answer = await prompt({
    type: 'input',
    name: 'file',
    message: 'Please provide the input file path:',
    validate: (input) => input.length > 0 || 'File path is required'
  });
  options.file = answer.file;
}

// ❌ Bad: Just error and exit
if (!options.file) {
  console.error('Error: File path is required');
  process.exit(1);
}
```

### 1.3 Stateful Data Management

**RULE**: Remember user preferences and settings between CLI invocations.

**DO**:

- Store configuration in XDG-compliant locations
- Use `~/.config/your-app/` for user configs
- Persist API tokens, preferences, and settings
- Provide clear config management commands

**Example**:

```typescript
// ✅ Good: XDG-compliant config storage
import { join } from 'path';
import { homedir } from 'os';

const configDir = process.env.XDG_CONFIG_HOME || join(homedir(), '.config');
const appConfigDir = join(configDir, 'your-app');
const configFile = join(appConfigDir, 'config.json');

// Ensure config directory exists
await fs.mkdir(appConfigDir, { recursive: true });
```

**Required packages**: Use `configstore` or `conf` for configuration management.

### 1.4 Colorful Output with Graceful Degradation

**RULE**: Use colors for better UX but always provide fallbacks.

**DO**:

- Detect terminal color support automatically
- Respect `NO_COLOR` environment variable
- Provide `--no-color` CLI flag
- Gracefully degrade in non-color terminals

**Example**:

```typescript
// ✅ Good: Color-aware output
import chalk from 'chalk';

const supportsColor = process.stdout.hasColors();
const colorize = supportsColor ? chalk : {
  green: (text: string) => text,
  red: (text: string) => text,
  blue: (text: string) => text
};

console.log(colorize.green('Success!'));
console.log(colorize.red('Error!'));

// ❌ Bad: Hard-coded colors
console.log('\x1b[32mSuccess!\x1b[0m'); // May not work everywhere
```

**Required packages**: Use `chalk`, `kleur`, or `colors` with proper fallbacks.

### 1.5 Rich Interactive Experiences

**RULE**: Use advanced prompts and progress indicators for better UX.

**DO**:

- Use interactive prompts for complex inputs
- Show progress bars for long operations
- Provide auto-complete suggestions
- Use spinners for loading states

**Example**:

```typescript
// ✅ Good: Rich interactions
import { prompt } from 'enquirer';
import ora from 'ora';

// Interactive selection
const { framework } = await prompt({
  type: 'select',
  name: 'framework',
  message: 'Choose your framework:',
  choices: ['React', 'Vue', 'Angular', 'Svelte']
});

// Progress indicator
const spinner = ora('Installing dependencies...').start();
try {
  await installDependencies();
  spinner.succeed('Dependencies installed successfully!');
} catch (error) {
  spinner.fail('Installation failed');
}
```

**Required packages**: Use `enquirer`, `ora`, `ink`, or `prompts`.

### 1.6 Hyperlink Support

**RULE**: Make URLs and file references clickable in modern terminals.

**DO**:

- Format URLs as `https://example.com`
- Format file references as `src/file.ts:10:15`
- Use proper terminal hyperlink formatting

**Example**:

```typescript
// ✅ Good: Clickable links
console.log('Documentation: https://docs.example.com');
console.log('Source: src/utils.ts:25:30');

// For file references with line numbers
const formatFileReference = (file: string, line: number, column: number) => {
  return `${file}:${line}:${column}`;
};
```

### 1.7 Zero Configuration

**RULE**: Auto-detect configuration and provide sensible defaults.

**DO**:

- Detect environment automatically
- Use environment variables for configuration
- Provide sensible defaults for all options
- Only prompt when absolutely necessary

**Example**:

```typescript
// ✅ Good: Auto-detection
const detectConfig = () => {
  return {
    port: process.env.PORT || 3000,
    host: process.env.HOST || 'localhost',
    debug: process.env.DEBUG === 'true',
    config: process.env.CONFIG_FILE || './config.json'
  };
};

// Only prompt for critical missing data
if (!process.env.API_KEY && !config.apiKey) {
  const { apiKey } = await prompt({
    type: 'password',
    name: 'apiKey',
    message: 'API key is required:'
  });
  config.apiKey = apiKey;
}
```

### 1.8 POSIX Signal Handling

**RULE**: Properly handle process signals for graceful shutdowns.

**DO**:

- Handle SIGINT (Ctrl+C) gracefully
- Clean up resources before exit
- Handle SIGTERM for container environments
- Provide graceful shutdown messages

**Example**:

```typescript
// ✅ Good: Signal handling
let isShuttingDown = false;

const gracefulShutdown = async (signal: string) => {
  if (isShuttingDown) return;
  isShuttingDown = true;
  
  console.log(`\nReceived ${signal}, shutting down gracefully...`);
  
  // Cleanup operations
  await cleanup();
  
  process.exit(0);
};

process.on('SIGINT', () => gracefulShutdown('SIGINT'));
process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));

// ❌ Bad: No signal handling
// process.on('SIGINT', () => process.exit(0)); // Abrupt exit
```

## 2. Distribution

### 2.1 Minimize Dependencies

**RULE**: Keep production dependencies minimal and lightweight.

**DO**:

- Audit dependency sizes with Bundlephobia
- Use smaller alternatives when possible
- Avoid heavy frameworks for simple tasks
- Bundle dependencies when appropriate

**Example**:

```typescript
// ✅ Good: Lightweight alternatives
// Instead of moment.js (67.6kB)
import { format } from 'date-fns'; // 13.1kB

// Instead of lodash (69.3kB)
const isEmpty = (obj: any) => Object.keys(obj).length === 0;
const debounce = (fn: Function, delay: number) => {
  let timeoutId: NodeJS.Timeout;
  return (...args: any[]) => {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn(...args), delay);
  };
};
```

### 2.2 Use Lockfiles

**RULE**: Always include lockfiles for reproducible builds.

**DO**:

- Use `package-lock.json` or `yarn.lock`
- Commit lockfiles to version control
- Pin exact dependency versions
- Document dependency update process

**Example**:

```json
// package.json
{
  "scripts": {
    "prepublishOnly": "npm run build",
    "postinstall": "node scripts/postinstall.js"
  },
  "engines": {
    "node": ">=16.0.0"
  }
}
```

### 2.3 Clean Configuration Files

**RULE**: Provide uninstall options and cleanup configuration.

**DO**:

- Include `--uninstall` flag
- Clean up config files on uninstall
- Ask user before removing configs
- Provide backup options

**Example**:

```typescript
// ✅ Good: Uninstall handling
program
  .command('uninstall')
  .description('Remove CLI and clean up configuration')
  .option('--keep-config', 'Keep configuration files')
  .action(async (options) => {
    if (!options.keepConfig) {
      const { confirm } = await prompt({
        type: 'confirm',
        name: 'confirm',
        message: 'Remove configuration files?'
      });
      
      if (confirm) {
        await cleanupConfig();
      }
    }
    
    await uninstallCLI();
  });
```

## 3. Interoperability

### 3.1 Accept STDIN Input

**RULE**: Support piping data from other commands.

**DO**:

- Read from `process.stdin` when no file specified
- Support both file and STDIN input
- Handle streaming data efficiently
- Provide clear input format documentation

**Example**:

```typescript
// ✅ Good: STDIN support
const getInput = async (filePath?: string): Promise<string> => {
  if (filePath) {
    return fs.readFile(filePath, 'utf-8');
  }
  
  // Read from STDIN
  if (process.stdin.isTTY) {
    throw new Error('No input file specified and no data piped');
  }
  
  return new Promise((resolve) => {
    let data = '';
    process.stdin.on('data', chunk => data += chunk);
    process.stdin.on('end', () => resolve(data));
  });
};
```

### 3.2 Structured Output

**RULE**: Provide machine-readable output formats.

**DO**:

- Support `--json` flag for structured output
- Use consistent output formats
- Enable easy parsing by other tools
- Document output schema

**Example**:

```typescript
// ✅ Good: Structured output
const outputResult = (data: any, format: 'text' | 'json') => {
  if (format === 'json') {
    console.log(JSON.stringify(data, null, 2));
    return;
  }
  
  // Human-readable text output
  console.log(`Found ${data.count} items:`);
  data.items.forEach(item => {
    console.log(`- ${item.name}: ${item.description}`);
  });
};

program
  .option('--json', 'Output in JSON format')
  .action(async (options) => {
    const result = await processData();
    outputResult(result, options.json ? 'json' : 'text');
  });
```

### 3.3 Cross-Platform Compatibility

**RULE**: Ensure CLI works on Windows, macOS, and Linux.

**DO**:

- Use `path.join()` for path construction
- Handle different shell interpreters
- Test on multiple platforms
- Use cross-platform path separators

**Example**:

```typescript
// ✅ Good: Cross-platform paths
import { join } from 'path';

// Instead of string concatenation
const configPath = join(__dirname, '..', 'config', 'default.json');

// Handle different shells
const isWindows = process.platform === 'win32';
const shell = isWindows ? 'cmd.exe' : '/bin/bash';
const shellFlag = isWindows ? '/c' : '-c';

// ❌ Bad: Platform-specific paths
const configPath = __dirname + '/../config/default.json'; // Unix-specific
```

### 3.4 Configuration Precedence

**RULE**: Follow standard configuration hierarchy.

**DO**:

- Command line args (highest priority)
- Environment variables
- Project config files
- User config files
- System config files (lowest priority)

**Example**:

```typescript
// ✅ Good: Configuration precedence
const loadConfig = () => {
  const config = {
    // System defaults
    port: 3000,
    host: 'localhost',
    
    // User config
    ...loadUserConfig(),
    
    // Project config
    ...loadProjectConfig(),
    
    // Environment variables
    port: process.env.PORT || config.port,
    host: process.env.HOST || config.host,
    
    // Command line args (highest priority)
    ...program.opts()
  };
  
  return config;
};
```

## 4. Accessibility

### 4.1 Containerization

**RULE**: Provide Docker images for users without Node.js.

**DO**:

- Create multi-stage Dockerfile
- Publish to Docker Hub
- Include usage examples
- Optimize image size

**Example**:

```dockerfile
# Multi-stage Dockerfile
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

FROM node:18-alpine AS runtime
WORKDIR /app
COPY --from=builder /app/node_modules ./node_modules
COPY dist ./dist
ENTRYPOINT ["node", "dist/index.js"]
```

### 4.2 Graceful Degradation

**RULE**: Provide fallbacks for unsupported terminals.

**DO**:

- Auto-detect terminal capabilities
- Support `--no-color` and `--json` flags
- Skip animations in non-interactive mode
- Provide text alternatives

**Example**:

```typescript
// ✅ Good: Graceful degradation
const isInteractive = process.stdout.isTTY && !process.env.CI;
const supportsColor = process.stdout.hasColors && process.stdout.hasColors();

const displayProgress = (message: string) => {
  if (isInteractive && supportsColor) {
    // Rich progress with colors
    return ora(message).start();
  }
  
  // Simple text output
  console.log(message);
  return { succeed: (msg: string) => console.log(`✓ ${msg}`) };
};
```

### 4.3 Node.js Version Compatibility

**RULE**: Target supported Node.js versions only.

**DO**:

- Support LTS versions (currently 18.x, 20.x)
- Use `engines` field in package.json
- Check runtime version on startup
- Provide clear error messages for unsupported versions

**Example**:

```typescript
// ✅ Good: Version checking
const checkNodeVersion = () => {
  const requiredVersion = '18.0.0';
  const currentVersion = process.version;
  
  if (!semver.gte(currentVersion, requiredVersion)) {
    console.error(`❌ Node.js ${requiredVersion} or higher is required.`);
    console.error(`   Current version: ${currentVersion}`);
    console.error(`   Please upgrade Node.js: https://nodejs.org/`);
    process.exit(1);
  }
};

// Check on startup
checkNodeVersion();
```

### 4.4 Shebang Declaration

**RULE**: Use portable shebang for Node.js detection.

**DO**:

- Use `#!/usr/bin/env node`
- Avoid hardcoded Node.js paths
- Ensure executable permissions

**Example**:

```typescript
#!/usr/bin/env node

// Your CLI code here
import { program } from 'commander';
// ...
```

## 5. Testing

### 5.1 Locale-Independent Testing

**RULE**: Don't rely on specific locale text in tests.

**DO**:

- Test for functionality, not specific text
- Use stable identifiers in output
- Test with different locales
- Avoid hardcoded English text assertions

**Example**:

```typescript
// ✅ Good: Locale-independent testing
test('shows help when no args provided', async () => {
  const result = await runCLI([]);
  
  // Test for functionality, not specific text
  expect(result.exitCode).toBe(0);
  expect(result.stdout).toContain('--help');
  expect(result.stdout).toContain('--version');
});

// ❌ Bad: Locale-dependent testing
test('shows help when no args provided', async () => {
  const result = await runCLI([]);
  expect(result.stdout).toContain('Examples:'); // May fail in non-English locales
});
```

## 6. Error Handling

### 6.1 Trackable Error Codes

**RULE**: Provide unique, searchable error codes.

**DO**:

- Use consistent error code format (E####)
- Include error codes in all error messages
- Document error codes in README
- Make error codes easily searchable

**Example**:

```typescript
// ✅ Good: Trackable errors
class CLIError extends Error {
  constructor(code: string, message: string) {
    super(`Error (${code}): ${message}`);
    this.name = 'CLIError';
    this.code = code;
  }
}

const errors = {
  MISSING_API_KEY: 'E1001',
  INVALID_FILE_PATH: 'E1002',
  NETWORK_ERROR: 'E1003'
};

throw new CLIError(errors.MISSING_API_KEY, 'API key is required. Set API_KEY environment variable.');
```

### 6.2 Actionable Error Messages

**RULE**: Provide clear solutions with error messages.

**DO**:

- Explain what went wrong
- Provide specific fix instructions
- Include relevant documentation links
- Suggest alternative approaches

**Example**:

```typescript
// ✅ Good: Actionable errors
const handleMissingConfig = () => {
  console.error('❌ Configuration file not found');
  console.error('');
  console.error('To fix this:');
  console.error('  1. Run: your-cli init');
  console.error('  2. Or create config manually: your-cli config --create');
  console.error('');
  console.error('Documentation: https://docs.example.com/configuration');
  process.exit(1);
};
```

### 6.3 Debug Mode

**RULE**: Provide comprehensive debugging capabilities.

**DO**:

- Support `--debug` and `--verbose` flags
- Use environment variable `DEBUG=*`
- Log relevant execution details
- Provide stack traces when appropriate

**Example**:

```typescript
// ✅ Good: Debug mode
import debug from 'debug';

const log = debug('your-cli');

const runWithDebug = async (options: any) => {
  if (options.debug) {
    debug.enable('your-cli:*');
  }
  
  log('Starting CLI with options:', options);
  
  try {
    const result = await processData(options);
    log('Processing completed:', result);
    return result;
  } catch (error) {
    log('Error occurred:', error);
    throw error;
  }
};
```

### 6.4 Proper Exit Codes

**RULE**: Use standard exit codes for different scenarios.

**DO**:

- Exit with 0 on success
- Exit with 1 on general errors
- Use specific codes for different error types
- Document exit code meanings

**Example**:

```typescript
// ✅ Good: Proper exit codes
const exitCodes = {
  SUCCESS: 0,
  GENERAL_ERROR: 1,
  INVALID_INPUT: 2,
  FILE_NOT_FOUND: 3,
  NETWORK_ERROR: 4
};

try {
  await main();
  process.exit(exitCodes.SUCCESS);
} catch (error) {
  if (error.code === 'ENOENT') {
    console.error('File not found');
    process.exit(exitCodes.FILE_NOT_FOUND);
  }
  
  console.error('Unexpected error:', error.message);
  process.exit(exitCodes.GENERAL_ERROR);
}
```

### 6.5 Effortless Bug Reports

**RULE**: Make bug reporting as easy as possible.

**DO**:

- Include issue template URLs
- Pre-populate bug report data
- Provide `--report-bug` command
- Include version and environment info

**Example**:

```typescript
// ✅ Good: Bug reporting
program
  .command('report-bug')
  .description('Generate bug report')
  .action(async () => {
    const report = {
      version: packageJson.version,
      nodeVersion: process.version,
      platform: process.platform,
      arch: process.arch,
      timestamp: new Date().toISOString()
    };
    
    const issueUrl = `https://github.com/user/repo/issues/new?body=${encodeURIComponent(JSON.stringify(report, null, 2))}`;
    
    console.log('Bug report generated!');
    console.log(`Open issue: ${issueUrl}`);
    
    // Auto-open in browser if possible
    if (process.platform !== 'win32') {
      await import('open').then(open => open.default(issueUrl));
    }
  });
```

## 7. Development

### 7.1 Package.json Bin Configuration

**RULE**: Use object syntax for executable definitions.

**DO**:

- Decouple package name from executable name
- Use descriptive executable names
- Place executables in `bin/` directory

**Example**:

```json
{
  "name": "my-cli-tool",
  "bin": {
    "my-cli": "./bin/cli.js",
    "mct": "./bin/cli.js"
  }
}
```

### 7.2 Path Handling

**RULE**: Use correct path resolution methods.

**DO**:

- Use `process.cwd()` for user input paths
- Use `__dirname` for project file paths
- Use `path.join()` for path construction
- Handle relative paths correctly

**Example**:

```typescript
// ✅ Good: Path handling
import { join } from 'path';

// User input paths (relative to current working directory)
const userFilePath = join(process.cwd(), options.file);

// Project file paths (relative to script location)
const configPath = join(__dirname, '..', 'config', 'default.json');
const templatePath = join(__dirname, 'templates');

// ❌ Bad: Manual path construction
const configPath = __dirname + '/../config/default.json'; // Platform-specific
```

### 7.3 Package Files Field

**RULE**: Only include necessary files in published packages.

**DO**:

- Use `files` field to control package contents
- Exclude test files and development configs
- Include only runtime dependencies
- Keep package size minimal

**Example**:

```json
{
  "files": [
    "dist",
    "bin",
    "README.md",
    "LICENSE"
  ],
  "scripts": {
    "prepublishOnly": "npm run build"
  }
}
```

## 8. Analytics

### 8.1 Opt-in Analytics

**RULE**: Never collect analytics without explicit user consent.

**DO**:

- Ask for permission before collecting data
- Provide clear opt-out mechanisms
- Document what data is collected
- Respect user privacy preferences

**Example**:

```typescript
// ✅ Good: Opt-in analytics
const askForAnalytics = async () => {
  const { consent } = await prompt({
    type: 'confirm',
    name: 'consent',
    message: 'Help improve this tool by sharing anonymous usage data? (y/N)',
    initial: false
  });
  
  if (consent) {
    console.log('Analytics enabled. Thank you for helping improve this tool!');
    await enableAnalytics();
  } else {
    console.log('Analytics disabled. No data will be collected.');
  }
};

// Check on first run
if (!config.analyticsConsentAsked) {
  await askForAnalytics();
  config.analyticsConsentAsked = true;
  await saveConfig();
}
```

## 9. Versioning

### 9.1 Version Flag

**RULE**: Always include `--version` and `-V` flags.

**DO**:

- Display version from package.json
- Include build information if available
- Exit after displaying version
- Use standard version format

**Example**:

```typescript
// ✅ Good: Version handling
program
  .version(packageJson.version, '-v, --version')
  .description(packageJson.description);

// Or manually implement
if (options.version) {
  console.log(`${packageJson.name} version ${packageJson.version}`);
  console.log(`Node.js version ${process.version}`);
  process.exit(0);
}
```

### 9.2 Semantic Versioning

**RULE**: Follow SemVer strictly for all releases.

**DO**:

- Use MAJOR.MINOR.PATCH format
- Increment MAJOR for breaking changes
- Increment MINOR for new features
- Increment PATCH for bug fixes

### 9.3 Package.json Version

**RULE**: Keep version in package.json synchronized.

**DO**:

- Use `npm version` for updates
- Automate version increments
- Include version in all outputs
- Document versioning strategy

### 9.4 Version in Error Messages

**RULE**: Include version information in all error contexts.

**DO**:

- Show version in help text
- Include version in error messages
- Display version in debug output
- Make version easily accessible

### 9.5 Backward Compatibility

**RULE**: Maintain backward compatibility when possible.

**DO**:

- Document breaking changes clearly
- Provide migration guides
- Use deprecation warnings
- Support multiple versions when feasible

### 9.6 npm Publishing

**RULE**: Publish with proper version tags.

**DO**:

- Use `npm publish` for releases
- Tag releases appropriately
- Include release notes
- Maintain changelog

### 9.7 Release Documentation

**RULE**: Provide comprehensive release information.

**DO**:

- Write clear release notes
- Document breaking changes
- Include migration steps
- Update documentation

## 10. Security

### 10.1 Argument Injection Prevention

**RULE**: Validate and sanitize all user inputs.

**DO**:

- Validate file paths and arguments
- Avoid command injection vulnerabilities
- Use safe file operations
- Implement proper input validation

**Example**:

```typescript
// ✅ Good: Input validation
import { resolve, relative } from 'path';

const validateFilePath = (inputPath: string) => {
  const resolvedPath = resolve(inputPath);
  const relativePath = relative(process.cwd(), resolvedPath);
  
  // Prevent directory traversal attacks
  if (relativePath.startsWith('..') || relativePath.includes('..')) {
    throw new Error('Invalid file path: directory traversal not allowed');
  }
  
  return resolvedPath;
};

// Use validated path
const safePath = validateFilePath(options.file);
const content = await fs.readFile(safePath, 'utf-8');
```

## Implementation Checklist

When building a Node.js CLI, ensure you've implemented:

- [ ] POSIX-compliant argument parsing
- [ ] Interactive prompts for missing data
- [ ] Configuration persistence
- [ ] Colorful output with fallbacks
- [ ] Rich interactive experiences
- [ ] Clickable hyperlinks
- [ ] Zero-configuration defaults
- [ ] Proper signal handling
- [ ] Minimal dependencies
- [ ] Lockfile inclusion
- [ ] Uninstall cleanup
- [ ] STDIN support
- [ ] JSON output option
- [ ] Cross-platform compatibility
- [ ] Configuration precedence
- [ ] Docker containerization
- [ ] Graceful degradation
- [ ] Node.js version checking
- [ ] Portable shebang
- [ ] Locale-independent tests
- [ ] Trackable error codes
- [ ] Actionable error messages
- [ ] Debug mode support
- [ ] Proper exit codes
- [ ] Easy bug reporting
- [ ] Correct bin configuration
- [ ] Proper path handling
- [ ] Optimized package files
- [ ] Opt-in analytics
- [ ] Version flags
- [ ] Semantic versioning
- [ ] Security validation

## Required Dependencies

Essential packages for building production-ready CLIs:

```json
{
  "dependencies": {
    "commander": "^11.0.0",
    "chalk": "^5.0.0",
    "enquirer": "^2.3.6",
    "ora": "^7.0.1",
    "conf": "^10.0.3"
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "typescript": "^5.0.0"
  }
}
```

## Quick Start Template

```typescript
#!/usr/bin/env node

import { program } from 'commander';
import chalk from 'chalk';
import { version } from '../package.json';

// Version and description
program
  .version(version, '-v, --version')
  .description('A modern Node.js CLI tool');

// Global options
program
  .option('--debug', 'Enable debug mode')
  .option('--no-color', 'Disable colored output')
  .option('--json', 'Output in JSON format');

// Commands
program
  .command('init')
  .description('Initialize configuration')
  .action(async () => {
    // Implementation
  });

program
  .command('run')
  .description('Run the tool')
  .option('-f, --file <path>', 'Input file')
  .action(async (options) => {
    // Implementation
  });

// Parse and run
program.parse();
```

Follow these guidelines strictly to create professional, user-friendly Node.js CLI applications that follow industry best practices.
